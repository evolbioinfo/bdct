import logging
import os
import random
from functools import reduce
from itertools import chain
from multiprocessing.pool import ThreadPool

import numpy as np
import scipy
from matplotlib import rcParams
from matplotlib.pyplot import hist, legend, savefig, clf, title, show
from scipy.stats import stats
from wquantiles import quantile

from bdpn.tree_manager import TIME


class SortedSet():
    """
    Sorted set
    """

    def __init__(self, elements=None, key=lambda _: _):
        self.list = sorted(elements, key=key, reverse=True) if elements else []
        self.set = set(self.list)
        self.key = key

    def __len__(self):
        return len(self.set)

    def pop(self):
        value = None
        while value not in self.set:
            value = self.list.pop()
        self.set.remove(value)
        return value

    def remove(self, element):
        self.set.remove(element)

    def __str__(self):
        return '[{}]'.format(', '.join(_.name if getattr(_, 'name', '') else str(_) for _ in self))

    def __iter__(self):
        return (_ for _ in self.list if _ in self.set)

    def __contains__(self, key):
        return key in self.set


class Motif(object):

    def __init__(self, clustered_tips, root=None, exception_tips=None, notified2index_list=None):
        """
        A motif with exceptions.
        :param root: ete.TreeNode, the root of the motif subtree
        :param clustered_tips: list of clustered tips sorted by time
        :param exception_tips: set of exception tips
        """
        self.root = root if root else clustered_tips[0].get_common_ancestor(*clustered_tips)
        self.clustered_tips = clustered_tips
        self.exception_tips = exception_tips if exception_tips is not None \
            else set(self.root.iter_leaves()) - set(clustered_tips)
        self.notified2index_list = notified2index_list if notified2index_list is not None else {}

    def __str__(self):
        return "Motif with root {}, {} clustered tips ({}), and {} exceptions ({})" \
            .format(self.root.name, len(self.clustered_tips), ', '.join(_.name for _ in self.clustered_tips),
                    len(self.exception_tips), ', '.join(_.name for _ in self.exception_tips))


def nonparametric_cherry_diff(cherries, k=5, repetitions=1e4):
    """
    Calculates the branch differences in real (pseudo)cherries and in random ones.
    Random cherry configuration is generated by replacing each real (pseudo)cherry
    by a (pseudo)cherry whose tips are randomly drawn from a k-neighbourhood of the real (pseudo)cherry.
    The k-neighbourhood contains the k cherries whose roots are the closest in time to the (pseudo)cherry in question,
    including itself.

    We compare the first percentile of the real (pseudo)cherry branch differences
    to the distribution of those for the random configurations.

    :param repetitions: how many times a random (pseudo)cherry configuration should be generated.
    :param k: the size of the k-neighbourhood.
    :return: the proportion, between 0 and 1,
        of random 1st quantiles of (pseudo)cherry diffs less or equal to the real one.
    """
    cherries = sorted(cherries, key=lambda _: getattr(_.root, TIME))
    n = len(cherries)

    def get_diff(b1, b2):
        return abs(b1.dist - b2.dist)

    def get_diff_distribution(tip_list_collection):
        data, weights = [], []
        for tips in tip_list_collection:
            size = len(tips)
            # weight is calculated as (size / 2) / C^2_{size},
            # so that in total all possible cherries in this polytomy count as size / 2 cherries
            weight = 1 / (size - 1)
            # let's add all possible cherries with this weight
            for i in range(size - 1):
                for j in range(i + 1, size):
                    data.append(get_diff(tips[i], tips[j]))
                    weights.append(weight)
        return np.array(data), np.array(weights)

    def generate_random_cherries():
        for i in range(n):
            # replace the i-th (pseudo)cherry with a randomly generated one from the branches in its neighbourhood
            cherry = cherries[i]
            time_i = getattr(cherry.root, TIME)
            # get k nearest neighbours, our cherry being the closest
            neighbours = sorted(cherries[max(i - k, 0): min(i + k + 1, n)],
                                key=lambda _: (abs(getattr(_.root, TIME) - time_i),
                                               0 if _ == cherry else 1))[:k]
            # out of their tips pick as many as in our (pseudo)cherry
            yield random.sample(reduce(lambda l1, l2: l1 + l2, (_.clustered_tips for _ in neighbours), []),
                                len(cherry.clustered_tips))

    real_qt = quantile(*get_diff_distribution((_.clustered_tips for _ in cherries)), .25)

    def work(args):
        return quantile(*get_diff_distribution(generate_random_cherries()), .25)

    with ThreadPool() as pool:
        random_qts = pool.map(work, (() for _ in range(int(repetitions))))

    # random_qts = [quantile(*get_diff_distribution(generate_random_cherries()), .25) for _ in range(int(repetitions))]
    return sum(1 for _ in random_qts if _ <= real_qt) / repetitions


def plot_diffs(real_diffs, rand_diffs, path=None, tree_name='unnamed', year_start=None, year_end=None, pvalue=None):
    rcParams.update({'axes.titlesize': 'small', 'figure.autolayout': True})
    hist([real_diffs, rand_diffs[:len(real_diffs)]], alpha=0.5, label=['Real', 'Random'])
    years_str = '' if year_start is None or year_end is None else 'transmission in years {}-{}\n'.format(year_start,
                                                                                                         year_end)
    pvalue_str = '' if pvalue is None else 'p-value %g ' % pvalue
    title('Tree: {}\n{}{}(based on {} motifs)'.format(tree_name, years_str, pvalue_str, len(real_diffs)))
    legend()
    if path:
        savefig(path, format=os.path.splitext(os.path.basename(path))[1][1:])
    else:
        show()
    clf()


def get_pval(population1, population2):
    """
    Compares means of two populations.
    :param population1: list of values
    :param population2: list of values
    :return:
    """
    m1, m2 = np.mean(population1), np.mean(population2)
    s1, s2 = np.std(population1), np.std(population2)
    n1, n2 = len(population1), len(population2)
    z = (m1 - m2) / np.power(np.power(s1, 2) / n1 + np.power(s2, 2) / n2, .5)
    return scipy.stats.norm.sf(abs(z)) * 2


def community_tracing_test(*trees, pn_delay=0.1, repetitions=1e2):
    """
    Looks for the hints of community tracing.
    :param pn_delay: float, max delay between the current person sampling date
    and other people assumed to be in the same community
    :param repetitions: how many times a random configuration should be generated.
    :param trees: ete3.Tree(s), one or more trees.
    :return: the proportion, between 0 and 1, of random medians of phylogenetic diversity less or equal to the real one.
    """
    tip_collection = list(chain(*[_.iter_leaves() for _ in trees]))

    tips_feature = 'TIPS'
    for tree in trees:
        for _ in tree.traverse('postorder'):
            if _ .is_leaf():
                _.add_feature(tips_feature, {_})
            else:
                _.add_feature(tips_feature, set().union(*(getattr(c, tips_feature) for c in _.children)))

    def get_values(key=lambda _: getattr(_, TIME)):
        tips = sorted(tip_collection, key=key)
        cur_start = 0
        result = []
        n = len(tips)
        for i in range(n):
            community = set()
            dts = key(tips[i])
            while cur_start < n and key(tips[cur_start]) < (dts - pn_delay):
                cur_start += 1
            j = cur_start
            while j < n and (dts - pn_delay) <= key(tips[j]) <= (dts + pn_delay):
                community.add(tips[j])
                j += 1

            # let's find the community root
            root = next(iter(community))
            while len(getattr(root, tips_feature)) < len(community):
                root = root.up
            while len(getattr(root, tips_feature) & community) < len(community):
                root = root.up

            result.append(get_phylogenetic_biodiversity(community, root) / len(community))
        return result

    real_md = np.median(get_values())
    dts_list = [getattr(_, TIME) for _ in tip_collection]

    def shuffled_dts():
        random.shuffle(dts_list)
        return dts_list

    def work(tip2dts):
        return np.median(get_values(key=lambda _: tip2dts[_]))

    with ThreadPool() as pool:
        random_mds = pool.map(work, (dict(zip(tip_collection, shuffled_dts())) for _ in range(int(repetitions))))

    return sum(1 for _ in random_mds if _ <= real_md) / repetitions


def get_phylogenetic_biodiversity(tips, root=None):
    """
    For a subtree defined by a list of its tips, returns its phylogenetic biodiversity:
    sum of branch lengths.
    :param tips: list of ete3.TreeNode, tips
    :param root: ete3.TreeNode, (optional) the subtree root
    :return: float, phylogenetic biodiversity
    """
    if len(tips) <= 1:
        return 0

    if root is None:
        root = tips[0].get_common_ancestor(*tips)

    result = 0
    processed = {root}
    todo = list(tips)
    while todo:
        node = todo.pop()
        if node not in processed:
            result += node.dist
            processed.add(node)
            todo.append(node.up)

    return result


def tracing_test(*trees, k=5, repetitions=1e3):
    """
    Looks for the hints of partner notification.
    :param trees: ete3.Tree(s), one or more trees.
    :param repetitions: how many times a random (pseudo)cherry configuration should be generated.
    :param k: the size of the k-neighbourhood.
    :return: the proportion, between 0 and 1, of random 1st quantiles of (pseudo)cherry diffs less or equal to the real one.
    """
    motifs = list(chain(*[pick_cherries(_, include_polytomies=True) for _ in trees]))
    return nonparametric_cherry_diff(motifs, k=k, repetitions=repetitions)


def pick_cherries(tree, pn_lookback=np.inf, pn_delay=np.inf, include_polytomies=True):
    """
    Picks cherries that satisfy the given values of pn_lookback, pn_delay in the given tree.
    :param include_polytomies: bool, whether to transform polytomies in the tree into cherries,
    i.e. a polytomy of n tips will be transformed into n(n-1) cherries.
    :param tree: ete3.Tree, the tree of interest
    :param pn_lookback: float, max value of PN lookback
    (how old can a transmission be for a detected case to notify this partner)
    :param pn_delay: float, max delay between the notification and the sampling
    :return: iterator of Motif motifs
    """
    for cherry_root in (set(tip.up for tip in tree) if not tree.is_leaf() else set()):
        if not include_polytomies and len(cherry_root.children) != 2:
            continue
        tips = sorted([_ for _ in cherry_root.children if _.is_leaf()], key=lambda _: _.dist)
        if len(tips) < 2:
            continue

        tip_set = set(tips)

        prev_i, prev_n = None, None
        notified2index_list = {}
        clustered_tips = []
        for (i, n) in zip(tips[:-1], tips[1:]):
            if i.dist <= pn_lookback and (n.dist - i.dist) <= pn_delay:
                # start of a new motif
                if prev_n != i:
                    if prev_n is not None:
                        yield Motif(clustered_tips=clustered_tips, root=cherry_root,
                                    exception_tips=tip_set - set(clustered_tips),
                                    notified2index_list=notified2index_list)
                    notified2index_list = {}
                    clustered_tips = [i]
                notified2index_list[n] = i
                clustered_tips.append(n)
                prev_i, prev_n = i, n
        if prev_n is not None:
            yield Motif(clustered_tips=clustered_tips, root=cherry_root, exception_tips=tip_set - set(clustered_tips),
                        notified2index_list=notified2index_list)


def pick_communities(tree, pn_delay):
    """
    Picks communities that satisfy the given values of pn_delay in the given tree.
    :param tree: ete3.Tree, the tree of interest
    :param pn_delay: float, max delay between the notification and the sampling
    :return: iterator of Motif motifs
    """
    # sorted by TIME
    sorted_tips = SortedSet(tree.get_leaves(), key=lambda _: getattr(_, TIME))

    # the oldest unprocessed tip
    index_tip = sorted_tips.pop()
    last_TIME = getattr(index_tip, TIME)
    clustered_tips = [index_tip]

    while sorted_tips:
        notified_tip = sorted_tips.pop()
        notified_TIME = getattr(notified_tip, TIME)
        if notified_TIME - last_TIME < pn_delay:
            clustered_tips.append(notified_tip)
        else:
            if len(clustered_tips) > 1:
                yield Motif(clustered_tips=clustered_tips)
            clustered_tips = [notified_tip]
        last_TIME = notified_TIME

    if len(clustered_tips) > 1:
        yield Motif(clustered_tips=clustered_tips)



def pick_motifs(tree, pn_lookback, pn_delay, include_trivial=True, list_all_potential_notifiers=True):
    """
    Picks motifs that satisfy the given values of pn_lookback, pn_delay in the given tree.
    :param tree: ete3.Tree, the tree of interest
    :param pn_lookback: float, max value of PN lookback
    (how old can a transmission be for a detected case to notify this partner)
    :param pn_delay: float, max delay between the notification and the sampling
    :param include_trivial: bool, whether to include trivial one-node motifs in the output
    :param list_all_potential_notifiers: bool, whether to (True) list all potential notifiers
    for each detected notified node, or (False) just one (the closest in time)
    :return: iterator of Motif motifs
    """
    # sorted by TIME
    sorted_tips = SortedSet(tree.get_leaves(), key=lambda _: getattr(_, TIME))

    while sorted_tips:
        # the oldest unprocessed tip
        index_tip = sorted_tips.pop()
        index_TIME = getattr(index_tip, TIME)

        clustered_tips = [index_tip]

        cur_root = climb_up_tree(index_tip, pn_lookback)
        cur_sorted_tips = sorted(cur_root.get_leaves(), key=lambda _: getattr(_, TIME))

        notified2index = {}
        for notified_tip in cur_sorted_tips:
            # if it is our index tip skip it
            if notified_tip == index_tip:
                continue
            # if it is an exception in the past, we have already processed this tip in another motif
            if getattr(notified_tip, TIME) < index_TIME:
                continue

            potential_notifiers = get_potential_notifiers(notified_tip, clustered_tips, pn_lookback, pn_delay)
            # convert a generator to either a list or its first value
            potential_notifiers = list(potential_notifiers) \
                if list_all_potential_notifiers else next(potential_notifiers, None)
            if potential_notifiers:
                clustered_tips.append(notified_tip)
                notified2index[notified_tip] = potential_notifiers
        # the first clustered tip is our index tip and we've already removed it with sorted_tips.pop()
        for notified_tip in clustered_tips[1:]:
            sorted_tips.remove(notified_tip)

        if include_trivial or len(clustered_tips) > 1:
            yield Motif(clustered_tips=clustered_tips, notified2index_list=notified2index)


if __name__ == '__main__':
    from tree_generator import simulate_pn_tree_gillespie

    logging.basicConfig(level=logging.DEBUG, format='%(asctime)s %(message)s', datefmt="%Y-%m-%d %H:%M:%S")

    pn_delay = .5
    sampling_rate, bifurcation_rate, death_rate, notification_rate = 1 / 10, 1 / 2, 1 / 50, 1 / pn_delay

    logging.info('\n=================\n'
                 'Real parameter values:\n'
                 '\tPN delay:\t{} years,\n'
                 '\ttransmission rate:\t{},\n'
                 '\tsampling rate:\t{},\n'
                 '\tdeath rate:\t{},\n'
                 '\tnotification rate:\t{}.'.format(pn_delay, bifurcation_rate,
                                                    sampling_rate, death_rate, notification_rate))

    for (pn_prob_index, pn_prob_partner, community, pn_lookback, max_time) in [(.5, .5, True, 20, 80),
                                                                               (.5, .5, False, 4, 25),
                                                                               (0, 0, False, 0, 20)]:
        logging.info('\n\n\n=================\nWITH{} notification ({})\n=================\n'.format(
            '' if pn_prob_index else 'OUT',
            'CT' if community else 'PN'))

        tree = None
        while not tree or len(tree) < 1000:
            tree, _, _ = simulate_pn_tree_gillespie(sampling_rate, bifurcation_rate, death_rate,
                                                    notification_rate, max_time, pn_lookback, pn_prob_index,
                                                    pn_prob_partner,
                                                    snowballing=not community,
                                                    community=community, max_sampled=np.inf)
        logging.info('Generated a tree of size {}'.format(len(tree)))
        res = tracing_test(tree)
        logging.info('PN test: {}'.format(res))
        res = community_tracing_test(tree)
        logging.info('CT test: {}'.format(res))
